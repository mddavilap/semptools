---
title: "A quick start guide on using semptools"
author: "Shu Fai Cheung & Mark Hok Chio Lai"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{quick_start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width  =  6,
  fig.height =  6,
  fig.align = "center"
)
```

```{r setup, echo = FALSE}
library(semptools)
```

# Introduction

This package contains functions that *post-process* an output from 
`semPlot::semPaths`, to help users to customize the appearance of the graphs 
generated by `semPlot::semPaths`.

The following sections were written to be self-contained, with some elements 
repeated, such that each of them can be read individually.

# Mark all parameter estimates by asterisks based on p-Value: `mark_sig`

Let us consider a simple path analysis model:

```{r mark_sig01}
library(lavaan)
mod_pa <- 
 'x1 ~~ x2
  x3 ~  x1 + x2
  x4 ~  x1 + x3
 '
fit_pa <- lavaan::sem(mod_pa, pa_example)
summary(fit_pa)
```

This is the plot from `semPaths`.

```{r}
library(semPlot)
m <- matrix(c("x1",   NA,  NA,   NA,
                NA, "x3",  NA, "x4",
              "x2",   NA,  NA,   NA), byrow = TRUE, 3, 4)
p_pa <- semPaths(fit_pa, whatLabels = "est",
           sizeMan = 10,
           edge.label.cex = 1.15,
           style = "ram", 
           nCharNodes = 0, nCharEdges = 0,
           layout = m)
```

We know from the `lavaan` output that some paths are significant and some are
not. In some disciplines, asterisks are conventionally added indicate this.
However, `sempPaths` does not do this. We can use `mark_sig` to add asterisks
based on the p-values of the free parameters.
  
```{r}
library(semptools)
p_pa2 <- mark_sig(p_pa, fit_pa)
plot(p_pa2)
```

The first argument, `semPaths_plot`, is the output from `semPaths::semPlot`. 
The second argument, `object`, is the `lavaan` output used to generate the plot. This 
output is needed to extract the *p*-values.

The default labels follow the common convention: "\*" for *p* less than .05, 
"\*\*" for *p* less than .01, and "\*\*\*" for p less than .001. This can be 
changed by the argument `alpha` (this must be named as the it is not the 
second argument). E.g.: 

```{r}
p_pa3 <- mark_sig(p_pa, fit_pa, alpha = c("(n.s.)" = 1.00, "*" = .01))
plot(p_pa3)
```

# Add standard error estimates to parameter estimates: `mark_se`

Let us consider a simple path analysis model:

```{r}
library(lavaan)
mod_pa <- 
  'x1 ~~ x2
   x3 ~  x1 + x2
   x4 ~  x1 + x3
  '
fit_pa <- lavaan::sem(mod_pa, pa_example)
summary(fit_pa)
```

This is the plot from `semPaths`.

```{r}
library(semPlot)
m <- matrix(c("x1",   NA,  NA,   NA,
                NA, "x3",  NA, "x4",
              "x2",   NA,  NA,   NA), byrow = TRUE, 3, 4)
p_pa <- semPaths(fit_pa, whatLabels = "est",
           sizeMan = 10,
           edge.label.cex = 1.15,
           style = "ram", 
           nCharNodes = 0, nCharEdges = 0,
           layout = m)
```

We can use `mark_se` to add the standard errors for the parameter estimates:

```{r}
library(semptools)
p_pa2 <- mark_se(p_pa, fit_pa)
plot(p_pa2)
```

The first argument, `semPaths_plot`, is the output from `semPaths::semPlot`. 
The second argument, `object`, is the `lavaan` output used to generate the 
plot. This output is needed to extra the standard errors.

By default, the standard errors are enclosed by parentheses and appended to 
the parameter estimates, separated by one space. The argument `sep` can be 
used to use another separator. For example, if `"\n"` is used, the standard 
errors will be displayed below the corresponding parameter estimates.

```{r}
p_pa2 <- mark_se(p_pa, fit_pa, sep = "\n")
plot(p_pa2)
```

# Rotate the residuals of selected variables: `rotate_resid`

Let us consider a simple path analysis model:

```{r}
library(lavaan)
mod_pa <- 
 'x1 ~~ x2
  x3 ~  x1 + x2
  x4 ~  x1 + x3
 '
fit_pa <- lavaan::sem(mod_pa, pa_example)
summary(fit_pa)
```

This is the plot from `semPaths`.

```{r}
library(semPlot)
m <- matrix(c("x1",   NA,  NA,   NA,
                NA, "x3",  NA, "x4",
              "x2",   NA,  NA,   NA), byrow = TRUE, 3, 4)
p_pa <- semPaths(fit_pa, whatLabels = "est",
           sizeMan = 10,
           edge.label.cex = 1.15,
           style = "ram", 
           nCharNodes = 0, nCharEdges = 0,
           layout = m)
```

Suppose we want to rotate the residuals of some variables to improve readability.

- For `x3`, we want to place the residual to top-right corner.

- For `x4`, we want to place the residual to the top-left corner.

- For `x2`, we want to place the residual to the left.

We first need to decide the angle of placement, in degrees.

Top is 0 degree. Clockwise position is positive, and counterclockwise 
position is negative.

Therefore, top-right is 45, top-left is -45, and left is -90.

We create a `list` of `lists`. In each sublist, there are two elements: `node
` denotes that variable (`node`) name, and `rotate` is the degree of the 
position.

We then use `rotate_resid` to post-process the `semPaths` output. The first 
argument, `semPaths_plot`, is the `semPaths` output. The second argument, `
rotate_resid_list`, is the list to specify how the residuals should be rotated.


```{r}
library(semptools)
my_rotate_resid_list <- list(list(node = "x3", rotate =  45),
                             list(node = "x4", rotate = -45),
                             list(node = "x2", rotate = -90))
 
p_pa2 <- rotate_resid(p_pa, my_rotate_resid_list)
plot(p_pa2)
```

# Set the curve attributes of selected arrows: `set_curve`

Let us consider a simple path analysis model:

```{r}
library(lavaan)
mod_pa <- 
 'x1 ~~ x2
  x3 ~  x1 + x2
  x4 ~  x1 + x3
 '
fit_pa <- lavaan::sem(mod_pa, pa_example)
summary(fit_pa)
```

This is the plot from `semPaths`.

```{r}
library(semPlot)
m <- matrix(c("x1",   NA,  NA,   NA,
                NA, "x3",  NA, "x4",
              "x2",   NA,  NA,   NA), byrow = TRUE, 3, 4)
p_pa <- semPaths(fit_pa, whatLabels = "est",
           sizeMan = 10,
           edge.label.cex = 1.15,
           style = "ram", 
           nCharNodes = 0, nCharEdges = 0,
           layout = m)
```

Suppose we want to change the curvature of these two arrows (`edges`):

- Have the `x1 ~~ x2` covariance curved "away" from the center.

- Have the `x4 ~ x1` path curved upward.

We create a `list` of `lists`. In each sublist, there are three elements: `
from` denotes the left hand side of the arrow, `to` denotes the right hand 
side of the arrow, and `new_curve` denote the new curvature for this arrow. 
The `from` and `to` will be based on the `lavaan` parameter tables, which can 
be found by `lavaan::parameterEstimates`:

```{r}
lavaan::parameterEstimates(fit_pa)
```

We can see that the double-headed arrow for `x1` and `x2` has `x1` on the left
 hand side and `x2` on the right hand side. Therefore, `from` should be set to
 `x1` and `to` should be set to `x2`.


It is not easy to decide what the value should be used. Trial and error is 
needed for complicated model. The `curve` attributes of the corresponding arrows
of the `qgraph` object will be updated.
 
We then use `set_curve` to post-process the `semPaths` output. The first 
argument, `semPaths_plot`, is the `semPaths` output. The second argument, `
curve_list`, is the list to specify the new curvature of the selected arrows.


```{r}
library(semptools)
my_curve_list <- list(list(from = "x1", to = "x2", new_curve = -1),
                    list(from = "x1", to = "x4", new_curve =  1)) 
p_pa2 <- set_curve(p_pa, my_curve_list)
plot(p_pa2)
```

This example shows how curvature of the two arrows are affected by other values:

```{r}
my_curve_list <- list(list(from = "x1", to = "x2", new_curve = -3),
                    list(from = "x1", to = "x4", new_curve =  2))
p_pa2 <- set_curve(p_pa, my_curve_list)
plot(p_pa2)
```

# Set the positions of parameters of selected arrows: `set_edge_label_position`


Let us consider a simple path analysis model:

```{r}
library(lavaan)
mod_pa <- 
 'x1 ~~ x2
  x3 ~  x1 + x2
  x4 ~  x1 + x3
 '
fit_pa <- lavaan::sem(mod_pa, pa_example)
summary(fit_pa)
```

This is the plot from `semPaths`.

```{r}
library(semPlot)
m <- matrix(c("x1",   NA,  NA,   NA,
                NA, "x3",  NA, "x4",
              "x2",   NA,  NA,   NA), byrow = TRUE, 3, 4)
p_pa <- semPaths(fit_pa, whatLabels = "est",
           sizeMan = 10,
           edge.label.cex = 1.15,
           style = "ram", 
           nCharNodes = 0, nCharEdges = 0,
           layout = m)
```

Suppose we want to move the parameter estimates this way:

 - For the `x4 ~ x1` path, move the parameter estimates closer to `x4`.

 - For the `x3 ~ x1` path, move the parameter estimates closer to `x1`.

 - For the `x3 ~ x2` path, move the parameter estimates closer to `x2`.
 
We create a `list` of `lists`. In each sublist, there are three elements: `
from` denotes the left hand side of the arrow, `to` denotes the right hand 
side of the arrow, and `new_position` denote the new position of the parameter
 estimate. The mid point of the arrow is .50. Increasing this number moves the
 parameter estimate closer to the right hand side variable. Decreasing this 
number moves the parameter to the left hand side variable. The `from` and `to
` will be based on the `lavaan` parameter tables, which can be found by `
lavaan::parameterEstimates`:

```{r}
lavaan::parameterEstimates(fit_pa)
```

We can see that the arrow from `x1` to `x4` has `x1` on the left
 hand side and `x4` on the right hand side. Therefore, `from` should be set to
 `x1` and `to` should be set to `x4`. For single-headed arrows, this step is not
 necessary. However, for double-headed arrows, we need to check the `lavaan` 
 table to see which variable is on the left and which is on the right.

We then use `set_edge_label_position` to post-process the `semPaths` output. 
The first argument, `semPaths_plot`, is the `semPaths` output. The second 
argument, ` position_list`, is the list to specify the new position of the 
selected arrows. 

```{r}
library(semptools)
my_position_list <- list(list(from = "x1", to = "x3", new_position =  .25),
                         list(from = "x2", to = "x3", new_position =  .25),
                         list(from = "x1", to = "x4", new_position =  .75))
p_pa2 <- set_edge_label_position(p_pa, my_position_list)
plot(p_pa2)
```

# Using pipe-operator

All the functions support the `%>%` operator from `magrittr`. Therefore, we 
can chain the post-processing.

```{r}
library(lavaan)
mod_pa <- 
 'x1 ~~ x2
  x3 ~  x1 + x2
  x4 ~  x1 + x3
 '
fit_pa <- lavaan::sem(mod_pa, pa_example)
```

We will do this:

- Change the curvature of `x1 ~~ x2`

- Rotate the residuals of `x1`, `x2`, `x3`, and `x4`,

- Add asterisks to denote significant test results

- Add standard errors

- Move the parameter estimate of the `x4 ~ x1` path closer to `x4`.

```{r}
library(semPlot)
m <- matrix(c("x1",   NA,  NA,   NA,
                NA, "x3",  NA, "x4",
              "x2",   NA,  NA,   NA), byrow = TRUE, 3, 4)
p_pa <- semPaths(fit_pa, whatLabels = "est",
           sizeMan = 10,
           edge.label.cex = 1.15,
           style = "ram", 
           nCharNodes = 0, nCharEdges = 0,
           layout = m)
my_position_list <- list(list(from = "x1", to = "x4", new_position =  .75))
my_curve_list <- list(list(from = "x1", to = "x2", new_curve = -2))
my_rotate_resid_list <- list(list(node = "x1", rotate =   0),
                             list(node = "x2", rotate = 180),
                             list(node = "x3", rotate = 140),
                             list(node = "x4", rotate = 140))
my_position_list <- list(list(from = "x1", to = "x4", new_position =  .65))

library(magrittr)
p_pa2 <- p_pa %>% set_curve(my_curve_list) %>% 
                  rotate_resid(my_rotate_resid_list) %>% 
                  mark_sig(fit_pa) %>%
                  mark_se(fit_pa, sep = "\n") %>%
                  set_edge_label_position(my_position_list)
plot(p_pa2)
```

Note that the package `magrittr` needed to be loaded first.

For most of the functions, the necessary argument beside the ` semPaths` 
object, if any, if the second element. Therefore, they can be included as 
unnamed arguments. For the third and other optional arguments, such as `sep` 
for `mark_se`, it is better to name them.


# Limitations

- Currently, if a function needs the SEM output, only lavaan output is supported.